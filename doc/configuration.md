# Configuration

API of this framework, configuration the information data such as about RDBMS, Redis, GraphQL base on user-defined immutable data mode.

## 1. Simple ORM

If the association fields have no parameters, simple ORM configuration is engouh, like this
```kt
    entity(BookStore::class) {
        db {
            table("BOOK_STORE")
        }
        mappedList(BookStore::books, Book::store)
    }

    entity(Book::class) {
        db {
            table("BOOK")
        }
        reference(Book::store) {
            db {
                foreignKey("BOOK_ID", onDelete = OnDeleteAction.CASCADE)
            }
        }
        list(Book::authors) {
            db {
                middleTable("BOOK_AUTHOR_MAPPING", "BOOK_ID", "AUTHOR_ID")
            }
        }
    }

    entity(Author::class) {
        db {
            table("AUTHOR")
        }
        mappedList(Author::books, Book::authors)
    }
```

We see that this is a very simple ORM configuration, no difference from the traditional ORM framework.

After this configuration, developer need not need to implement SQL queries, need not to implement implement DataLoader/BatchLoader. 

This framework supports built-in redis cache, GraphQL queries first query redis instead of the database. This is an example of redis cache

|key          |Value             | Description|
|-------------|------------------|------------|
|gp_BookStore-1 | {id: "1", name: "O'REILLY"} | object cache |
|gp_BookStore-2 | {id: "2", name: "MANNING"} | object cache |
|gp_BookStore-1-books | [3, 4, 5] | association cache |
|gp_BookStore-2-books | [6] | association cache |

We have seen two types of caches here: object-cache and assocation-cache. In fact, there is a third redis cache: computed-cache, which we will be disucssed later.

**Developers can modify the database at will in the mutation, and the framework will automatically capture the developers' modifications to the database and automatically evict the affected from redis cache.** In order to achieve this function, the framework has few restrictions on developers, as follows

> 1. Must use R2DBC instead of JDBC to modify the database
> 
> 2. Must use ConnectionFactory proxied by this framework

## 2. Parameterized association

In actual projects, it is impossible to be as simple as the above example, and the associated attributes often have parameters.

Let us look at an example of adding an optional parameter named "name" to BookStore.books.

```kt
   entity(BookStore::class) {
        
        mappedList(BookStore::books, Book::store) {
            filter(Arg("name", String::class)) {
                args.string("name")?.let {
                    query.apply {
                        addCondition(
                            like(table[Book::name], it)
                        )
                    }
                }
            }
            redis {
                dependsOnList(BookStore::books) {
                    dependsOn(Book::name)
                }
            }
        }

        ... other code ...
    }
```

Here, we use the "filter" configuration to specify parameters for "BookStore.books". The code of the filter is very simple: If this parameter is specified by the user, add a dynamic condition to the SQL query automatically generated by the framework.

It is worth noting that the redis configuration, it tells the framework two things

1. dpendsOnList(BookStore::books) 
If the Book list of the BookStore object changes (may be creating a new Book object, or deleting the Book object, or modifying the foreign key of the Book), the data of current association in redis cache will be affected.

2. dependsOn(Book::name) 
If the name of the Book is modified, the data of current association in redis cache will be affected.

Now, the redis cache should looks like this

|key          |Value             | Description|
|-------------|------------------|------------|
|gp_BookStore-1 | {id: "1", name: "O'REILLY"} | object cache |
|gp_BookStore-2 | {id: "2", name: "MANNING"} | object cache |
|gp_BookStore-1-books | [3, 4, 5] | association cache |
|gp_BookStore-1-books-{name: "G"} | [3, 5] | parameterized association cache |
|gp_BookStore-2-books | [6] | association cache | parmaeterized association cache|
|gp_BookStore-2-books-{name: "X"} | [] | paramerized association cache |

## 3. Computed fields

Finally, letâ€™s take a look at an example of a calculated field

Book has a price attribute, and BookStore has an avgPrice attribute, which represents the average price of all data under the BookStore.

```kt
    entity(BookStore::class) {
        computed(BookStore::avgPrice) {
            batchImplementation {
                createStatement(
                    "select book_store_id, avg(price) from where book_store_id in (${
                        List(rows.size) { i -> "?${i + 1}" }.joinToString()
                    }) book group by book_store_id"
                )
                    .apply {
                        for (i in rows.indices) {
                            bind("${i + 1}", rows[i].id)
                        }
                    }
                    .execute()
                    .awaitSingle()
                    .map(Function<Readable, Pair<String, BigDecimal>> {
                        it.get(0, String::class.java) to it.get(1, BigDecimal::class.java)
                    })
                    .asFlow()
                    .toList()
            }
            redis {
                dependsOnList(BookStore::books) {
                    dependsOn(Book::price)
                }
            }
        }
    }
```

"computed" is used to config a computed field, "batchImplementation" is a R2DBC SQL query implemented by User.

It is worth noting that the redis configuration, it tells the framework two things

1. dpendsOnList(BookStore::books) 
If the Book list of the BookStore object changes (may be creating a new Book object, or deleting the Book object, or modifying the foreign key of the Book), the data "avgPrice" of the current BookStore in Redis cache will be affected

2. dependsOn(Book::name) 
If the "price" of the Book is modified, the data "avgPrice" of the current BookStore in Redis cache will be affected


Now, the redis cache should looks like this

|key          |Value             | Description|
|-------------|------------------|------------|
|gp_BookStore-1 | {id: "1", name: "O'REILLY"} | object cache |
|gp_BookStore-2 | {id: "2", name: "MANNING"} | object cache |
|gp_BookStore-1-books | [3, 4, 5] | association cache |
|gp_BookStore-1-books-{name: "G"} | [3, 5] | parameterized association cache |
|gp_BookStore-2-books | [6] | association cache | association cache|
|gp_BookStore-2-books-{name: "X"} | [] | paramerized association cache |
|gp_BookStore-1-avgPrice| 234.4 | computed cache |
|gp_BookStore-2-avgPrice| 51 | computed cache |

--------------------------------

[< Back](https://github.com/babyfish-ct/graphql-provider)
